* Introduction

~proxypox~ is my replacement for imgproxy written in Clojure. Mostly a learning experience, but I would like it to replace imgproxy in Alphabet Learning one day if possible.

* application flow

- the browser has ~img~ tags that point to our proxypox server via https.
- the ~img~ tags are generated by a django custom tag.
- when the browser request comes in, the image is requested from s3 and processing takes place (watermark, resize or degrade) and send back in the response.
- unsure whether we should be caching or not; currently serving a watermarked image seems to be very fast.
  
** how is the image url for the ~img~ tag created?

  - ref [[file:~/code/python/alphabetlearning/alphabetlearning/resources/templatetags/imageproxy_extras.py::--- Start: Your existing imgproxy URL generation logic ---][alphabet learning imageproxy_extras.py file]]
  - Uses these environment variables:
    - IMGPROXY_KEY, IMGPROXY_SALT, IMGPROXY_BASE_URL, AWS_STORAGE_BUCKET_NAME
  - gets the path to the object key (the file saved in s3)
  - constructs the full s3 url using the object key path and the AWS_STORAGE_BUCKET_NAME
  - encodes the full url in base64:
    - ~encoded_source_url = base64.urlsafe_b64encode(source_url.encode()).rstrip(b"=").decode()~
  - and so on....
  - the purpose is ensure that the imgproxy server only processes request that come from the authenticated server (the Django application) to prevent image processing taking place to create a DoD situation or to waste resources.
  - so, we have to do the same

** AI explanation of the crypto going on

I didn't understand it, and I still dont. AI said this. Basically, we are hashing the s3 url with SHA256, using keys shared between the django app (the client) and the imgproxy server (the server). [[https://gemini.google.com/app/9cfb7c4868a20bc7][Gemini answer]].

#+begin_src markdown
  The cryptography in your Django template tag is used to create a signed URL. This is a URL that contains a cryptographic signature to prove its authenticity and integrity. This method is a form of HMAC (Hash-based Message Authentication Code), which is a specific type of message authentication.

  The key pieces of cryptography are:

  ## HMAC

  The core cryptographic operation is the use of hmac.new() with hashlib.sha256. An HMAC uses a secret key to sign a message, creating a tag (the signature). This signature can be verified by anyone who also has the secret key. The message here is the URL path.

  -  Key: IMGPROXY_KEY is the secret key used for signing. It's a shared secret between your application and the imgproxy server.
  -  Message: path_to_sign is the message being signed. It consists of a salt and the URL path (/processing_options/encoded_source_url).
  -  HMAC-SHA256: This is the specific algorithm. It combines the SHA256 cryptographic hash function with the HMAC process. The output is a secure digest (the signature).

  ## Why imgproxy uses it and what it achieves:

  Imgproxy uses signed URLs to prevent unauthorized access and to ensure that image requests haven't been tampered with. It achieves:

  - Security: Only requests with a valid signature, generated with the correct secret key, will be processed. This prevents attackers from arbitrarily requesting images or image transformations on your imgproxy server. Without this, someone could flood your server with requests, leading to a denial-of-service attack or excessive resource usage.
  - Integrity: The signature is generated over the entire URL path, including the processing options (width, height, format, etc.). If an attacker tries to change any part of the URL, for example, changing the requested image format or dimensions, the signature will no longer be valid. The imgproxy server will recognize this as a tampered request and reject it.
  - Access Control: The signature provides a form of access control. It ensures that only requests originating from your trusted application—the one that holds the secret key—are fulfilled. It is a more secure alternative to simply using public, unprotected URLs.

  In short, this is an authentication and integrity mechanism. The signature on the URL proves that it was generated by a trusted source and that the parameters in the URL haven't been altered. This is a crucial security measure for a public-facing service like imgproxy.
#+end_src


* deps.edn

I need to brush up on what goes in here. [[https://clojure-doc.org/articles/tutorials/getting_started/][Clojure Guides]] is probably a good help to get started with.

#+begin_src clojure :results output :tangle deps.edn
    {:paths ["src"]
     :deps {org.clojure/clojure {:mvn/version "1.12.0"}
            http-kit/http-kit {:mvn/version "2.9.0-beta2"}}
     }
#+end_src

#+RESULTS:
: class clojure.lang.Compiler$CompilerException

* core.clj

This is just to get a hello world up and running.

This is the basic code to get an image from a URL.

We want to do this to get an image from S3.

#+begin_src clojure :results output :tangle src/org/yulqen/proxypox/core.clj
  (ns org.yulqen.proxypox.core)

  (require '[org.httpkit.client :as hclient])

  (import '[javax.imageio ImageIO])
  (import '[java.io ByteArrayInputStream])
  (import '[java.awt Graphics2D AlphaComposite])
  (import '[java.io File])

  (defn read-image-using-httpkit [url]
    (let [response @(hclient/get url {:as :byte-array})]
      (if-let [err (:error response)]
        (println "HTTP request failed:" err) ; Or throw an exception
        (if (= 200 (:status response))
          (let [image-data (:body response)]
            (ImageIO/read (ByteArrayInputStream. image-data)))
          (println "Request returned non-200 status:" (:status response))))))


  (defn read-image-from-url [url]
    (try
      (let [response (client/get url {:as :byte-array})
            image-data (:body response)]
        (ImageIO/read (ByteArrayInputStream. image-data)))
      (catch Exception e
        (println "Error reading image: " (.getMessage e))
        nil)))

  (defn -main []
    (println "Hello,world!"))

  (defn report-image-size [img-url]
    (let [image (read-image-from-url img-url)]
      (if image
        (println "Successfully read image with dimensions:"
                 (.getWidth image) "x" (.getHeight image)))))


  (defn apply-watermark [base-image watermark-image x y]
    "Applies a watermark-image onto the base-image at coordinates (x, y)."
    (let [g2d (.createGraphics base-image)
          watermark-width (.getWidth watermark-image)
          watermark-height (.getHeight watermark-image)]
      (.setComposite g2d (AlphaComposite/getInstance AlphaComposite/SRC_OVER (float 0.5)))
      (.drawImage g2d watermark-image x y nil)
      (.dispose g2d)
      base-image))

  (defn save-image [image filename]
    (ImageIO/write image "png" (File. filename)))

  (defn wm-image [base watermark]
    (let [base-image (read-image-from-url base)
          watermark-image (read-image-from-url watermark)
          watermarked-image (apply-watermark base-image watermark-image 0 0)]
      (save-image watermarked-image "/tmp/WATERMARKED_IMAGE.png")
      (println "Image with watermark saved!")))
#+end_src

#+RESULTS:
: class java.io.FileNotFoundException

* core.clj comment

We can put ideas and stuff we don't use into this comment.

This one gets the image dimensions.

#+begin_src clojure :results output :tangle src/org/yulqen/proxypox/core.clj
  (comment
    (defn report-image-size [img-url]
      (let [image (read-image-from-url img-url)]
        (if image
          (println "Successfully read image with dimensions:"
                   (.getWidth image) "x" (.getHeight image)))))
    )
#+end_src
